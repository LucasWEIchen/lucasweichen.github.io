{"meta":{"title":"鹿爷的人生杂货铺","subtitle":null,"description":"Lucas' memo in his Ph.D. career & SLAM Robotics & life","author":"Lucas WEI","url":"https://lucasweichen.github.io"},"pages":[],"posts":[{"title":"vivarium1","slug":"vivarium1","date":"2017-10-23T01:53:58.000Z","updated":"2017-10-23T02:46:39.985Z","comments":true,"path":"2017/10/22/vivarium1/","link":"","permalink":"https://lucasweichen.github.io/2017/10/22/vivarium1/","excerpt":"","text":"最近都在忙着给家里的鱼缸搬家，旧的三重底滤不靠谱，经常漏水还泡了我的地板。是时候做新缸了。无奈墨尔本没有一个像样的玻璃切割工厂，做出的设计图没有人愿意接，只能找到一个做亚克力的切割工厂，凑合做吧~ #1 附上雨林缸设计图一份 底部留有一个65mm直径的孔给底滤，还是内置三重底滤比较靠谱。以前的缸子是外置虹吸式三重底滤，各种不靠谱。估计人家都不愿意接这活也是应为这个洞。 整个缸子一米高，半米宽，400mm深，下方存水的部分30厘米高，上面有一个十厘米的挡板。中间留出60厘米的窗。现在窗还没有安装，以后上了植物再安装。 缸顶上开了一个二十厘米的长方形口子，走灯/风扇/喷淋的线路。 底滤是个储物盒自己改的，里面塞了两层带孔亚力克板，最下面是泵，加热棒，紫外灯，上面是滤材，生化棉等等。 65mm的洞直接拧上三重底滤套件，稍后给出购买传送门。 这样基本上过滤组件就完成了，现在加上灯饰。主要分为底部的观赏灯和顶部的植物灯。植物灯是很早以前的老鱼缸用的淘宝LED灯，当时买了三组。可是LED似乎对于半米以上的水深无能为力，用三组也无济于事，干脆撤了封存。这次正好拿出来用。三组产生的热量还是很可观的，正好后期还得加风扇，回头顺便给它们也吹吹。 剩下的就是观赏照明LED的，EBAY上淘来的车用12V LED 灯条买了好几组，很便宜。自己做好电源和接头，还可以买个遥控器，也没几美金。专门放了两个在水位线之下，方便看看水下世界。 经过一个礼拜的折腾，挑了几块沉木，试图营造出溶洞的效果。有点似像非像哈哈哈哈。沉木必然黄水，开灯以后也还好，看不出来。按照我的设计，水位线之上可以放一个兰花，之后上了背景板之后还可以再加几个空气凤梨和苔藓类。 things to do:还有几样事情没做 背景板 喷淋 给鱼搬家 加入超声波加湿器 顶部加风扇","categories":[{"name":"Aquarium","slug":"Aquarium","permalink":"https://lucasweichen.github.io/categories/Aquarium/"}],"tags":[{"name":"Vivarium","slug":"Vivarium","permalink":"https://lucasweichen.github.io/tags/Vivarium/"},{"name":"雨林缸","slug":"雨林缸","permalink":"https://lucasweichen.github.io/tags/雨林缸/"}]},{"title":"OpenCVimutilsNoneTypeError","slug":"OpenCVimutilsNoneTypeError","date":"2017-09-06T02:38:41.000Z","updated":"2017-09-06T02:43:18.576Z","comments":true,"path":"2017/09/05/OpenCVimutilsNoneTypeError/","link":"","permalink":"https://lucasweichen.github.io/2017/09/05/OpenCVimutilsNoneTypeError/","excerpt":"","text":"123456Traceback (most recent call last): File &quot;camlock/camlock2.py&quot;, line 76, in &lt;module&gt; frame = imutils.resize(frame, width=640, height= 480) File &quot;/usr/local/lib/python2.7/dist-packages/imutils/convenience.py&quot;, line 69, in resize (h, w) = image.shape[:2]AttributeError: &apos;NoneType&apos; object has no attribute &apos;shape&apos; 早上突然出现了这个错误。网上搜了很多都说是视频的源路径出错导致传给了imutils空的路径。可是测试树莓派摄像头时却一切正常。突然想起昨晚装的 v4l-2 驱动好像没加载。测试之后果然修复了NoneTypeError. 1sudo modprobe bcm2835-v4l2 It could be the path problem, but in my case it is the v4l2 thing that makes the trouble.","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://lucasweichen.github.io/categories/OpenCV/"}],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"https://lucasweichen.github.io/tags/Raspberry-Pi/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://lucasweichen.github.io/tags/OpenCV/"},{"name":"imutils","slug":"imutils","permalink":"https://lucasweichen.github.io/tags/imutils/"}]},{"title":"多个树莓派ROS设备在局域网内的安装与设置","slug":"ROSonMuiltiRaspi","date":"2017-08-18T05:58:04.000Z","updated":"2017-08-18T06:26:34.353Z","comments":true,"path":"2017/08/17/ROSonMuiltiRaspi/","link":"","permalink":"https://lucasweichen.github.io/2017/08/17/ROSonMuiltiRaspi/","excerpt":"","text":"#花了两天时间研究如何在RaspberryPi1 Model B 上面部署ROS系统。 现在简单的总结一下遇到的问题： 似乎Raspi1 model b+ 因为型号太老，只能承受 RoS indigo这个较老的版本。安装过程基本可以按照 Ros WIKI上面的文件 安装过程很久，makefile随随便便就是五六个小时。请准备好电影零食。 如果要连接Arduino，你会发现安装之后的indigo不带ROS的 rosserial package。这需要去单独下载。应为这个包还没有被包含在源服务器上，只能去git上面单独下载。 尽量在第一次make之前就把需要手动安装的package都下载到src文件夹下，这样可以省去你后面反复make的烦恼。 12345$ cd ~/ros_catkin_ws/src$ git clone https:// github.com/ros-drivers/rosserial#下面这两句会重新make一遍，又要去准备电影和零食。$ cd ~/ros_catkin_ws$ catkin_make 除了 rosserial， 我还用到了一个叫做common_msgs的包。地址是：https://github.com/ros/common_msgs安装原理与rosserial相同。 arduino 在树莓派1上没有被识别成ttyUSB设备。它指向ttyACM0。如果需要用ROS监听请设置好设备端口。在ROS环境下就是 1rosrun rosserial_python serial_node.py /dev/ttyACM0 当在局域网内使用多个ROS设备时，需要设置一个master来运行roscore. 请参考这个文档来设置。具体代码我放在这里备忘一下： 12#在所有子设备上都要设置export ROS_MASTER_URI=http://192.168.32.101:11311 Everything else just follow this.","categories":[{"name":"ROS","slug":"ROS","permalink":"https://lucasweichen.github.io/categories/ROS/"}],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"https://lucasweichen.github.io/tags/Raspberry-Pi/"},{"name":"ROS","slug":"ROS","permalink":"https://lucasweichen.github.io/tags/ROS/"},{"name":"Arduino","slug":"Arduino","permalink":"https://lucasweichen.github.io/tags/Arduino/"}]},{"title":"汇编语言MIPS的入门","slug":"mips","date":"2017-08-15T00:28:57.000Z","updated":"2017-08-18T06:19:57.910Z","comments":true,"path":"2017/08/14/mips/","link":"","permalink":"https://lucasweichen.github.io/2017/08/14/mips/","excerpt":"","text":"#最近一段时间都在忙着带汇编语言的课程。顺道自己也学了一下。 ##Monash University用Mips来介绍汇编语言环境。配合MARS Simulator进行测试。 ##其实隐隐觉得MARS里面有一些BUG， 很多时候程序的过程好像都不是很稳定。 Convention不同的写法和风格对应不同的convention。具体的中文翻译我说不上来，但是指的应该就是你写代码时参照的风格模板。 汇编与高级语言不同，其写法和逻辑自由度很高。 很多时候在不考虑效率的前提下可以衍生出很多方式去完成同一问题。这样会带来很多问题，尤其是别的程序员调用你的代码的时候，对你代码部分内存的调用，返回值的位置等等都不能准确的预判。这就使你编码的模板变得很重要。目测现存的汇编存在众多模板/convention可以使用。但要确认你在同一项目中使用相同的convention。#这是一份我觉得比较好用的Convention的reference sheet 要注意的是这并不是全部的指令，对于很多版本的convention还有一些高级指令可以调用。这个版本只是更方便于学生理解。 Loops在很多高级语言中for 和 while loop都只是一句话的事情。 而在mips中，写代码的人却需要考虑loop的位置，branch的具体跳转位置已经else部分应该放在哪里。这种特性就让while loop更容易在mips中实现，而for loop则变得稍微有些蹩脚。 ##对于python 的while loop 123456789n = int(input(&quot;Enter integer: &quot;))while (n &gt; 1):print(n)if n % 2 == 0:n = n//2else:n = 3*n + 1print(n) 转换到mips的逻辑大致是：12345678aLaberCalledLoop.beq/bne…aLaberCalledElse..j aLaberCalledLoopaLaberCalledElse 这里用到3个概念：laber， jump 和 branch。 都不难理解。如有问题请自行翻阅info sheet。另外对于jump，具体来说可以被分为4种：上面的例子用的是最简单的一直，其余的几种都与function的调用与返回有关。其实琢磨一下也没有什么，只是对于$pc（program counter）的值进行写入从而操纵下一行代码读取的位置罢了。 ##对于for loop基本的概念是和while loop差不多。这里唯一需要注意的就是else里面statement的写法和在程序中出现的位置。 python 代码123456def even_product(a_list): product = 1 for x in a_list: if x%2 ==0: product=product*x return product 当转换到mips时：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263.texteven_product: # save $fp and $raaddi $sp, $sp, -8sw $ra, 4($sp)sw $fp, 0($sp)# update $fpaddi $fp, $sp, 0# allocate local variablesaddi $sp, $sp, -8# setup productli $t0, 1sw $t0, -4($fp) # save product# setup ili $t0, 0sw $t0, -8($fp) # save iprodloop: lw $t0, -8($fp) # $t0 = ilw $t1, 8($fp) # $t1 = listlw $t2, 0($t1) # $t2 = len(list)bge $t0, $t2, endprod # check if i &lt; len(list)# restore xlw $t0, -8($fp) # $t0 = imul $t3, $t0, 4 # $t3 = 4*iaddi $t3, $t3, 4 # $t3 = 4*i + 4add $t3, $t3, $t1 # $t3 = address of list[i]lw $t3, 0($t3) # $t3 = list[i] = x# if x % 2 == 0li $t4, 2div $t3, $t4mfhi $t4bnez $t4, else # product = product*xlw $t4, -4($fp)mul $t4, $t4, $t3sw $t4, -4($fp)else: lw $t0, -8($fp)addi $t0, $t0, 1sw $t0, -8($fp)j prodloopendprod: # set returnlw $v0, -4($fp)# deallocate variablesaddi $sp, $sp, 8# restore $fp and $ralw $fp, 0($sp)lw $ra, 4($sp)addi $sp, $sp, 8jr $ra 需要注意的是，很多时候即使for loop中的statement成立，你的代码很可能还是需要执行接下的来的部分，也就是包含else的部分。这种情况下就需要谨慎对待else中的内容。基本上就意味着else中的内容在汇编中并不完全等于在高级语言中的内容。 stack 首先，在mips中，内存被从上到下分成5块：——–top———.data——-memory——-.text——-memory——-heap——-memory——-freespaces——-memory——-stack——–bottom——这样不难看出，data+text+heap位于内存的顶部，stack位于底部。而heap和stack中间的区域是未被利用的内存空间。使用这种排列方法的原因很简单：应为在程序初始化的时候data+text的大小是已知的。让heap从上往下生长，而stack从底部反向向上生长，所有的空白内存都留在了两者之间。这既保证了最大效率的利用内存，又不用担心如何分配stack的起始点。而这种分配带来的问题就是stack中内存使用的计算是反向的。每次给一个新的function初始化内存的时候，你都需要把pointer向上反向移动。比如现在pointer在0x2ff04(16进制内存地址，不熟悉的小伙伴小时候肯定没用过金手指)， 你要内一个新的程序初始化一个字段的内存，你需要减去4bits (0x2ff04-4 = 0x2ff00)。0x2ff00则是你新内存指针的位置。 listmips其实并不提供list这种高级数据格式。对于列表的操作更大程度上依赖于程序员对于stack/heap的理解。 ——–top———0x7FFF3128——-memory——-0x7FFF312C——-memory——-0x7FFF3130——-memory——-0x7FFF3134——-memory——-0x7FFF3138——-bottom—— 比如在如上的内存空间中，如果一开始，你的stack pointer（$sp）在0x7FFF3138的位置，你想写入一个3个单元的list。你需要做的如下： (1)把$sp减去3，向上反向移动3格。新的$sp指向0x7FFF312C (2)把list中的第一个值写入内存空间0x7FFF312C (3)把list中的第二个值写入内存空间0x7FFF3130 (4)把list中的第三个值写入内存空间0x7FFF3134 这样你就得到了一个list，占用三个内存空间。需要注意的是mips并不知道这是一个list。作为程序员，在之后的读取中你也要做类似的操作，在记住列表第一个元素的内存地址后，每+4便得到列表下一个值的位置。 先写这么多吧，在学习路上，如有错路请见谅并在回复中帮我指出谢谢！","categories":[{"name":"assembly","slug":"assembly","permalink":"https://lucasweichen.github.io/categories/assembly/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"assembly","slug":"assembly","permalink":"https://lucasweichen.github.io/tags/assembly/"},{"name":"mips","slug":"mips","permalink":"https://lucasweichen.github.io/tags/mips/"}]},{"title":"编码器续","slug":"encodermore","date":"2017-06-15T00:44:02.000Z","updated":"2017-06-15T01:11:25.536Z","comments":true,"path":"2017/06/14/encodermore/","link":"","permalink":"https://lucasweichen.github.io/2017/06/14/encodermore/","excerpt":"","text":"昨天把编码器接在了模拟信号口上并且胡乱设置了一个1000的阈值去测试，也算是成功了。今天接到数字信号上面用high和low值去学习编码器计数的操作。 上代码： 1234567891011121314151617181920212223242526272829303132333435/* Read Quadrature Encoder * Connect Encoder to Pins encoder0PinA, encoder0PinB, and +5V. * * Sketch by max wolf / www.meso.net * v. 0.1 - very basic functions - mw 20061220 * */ int val; int encoder0PinA = 3; int encoder0PinB = 4; int encoder0Pos = 0; int encoder0PinALast = LOW; int n = LOW; void setup() &#123; pinMode (encoder0PinA,INPUT); //channel A 插在DIGITAL 3 pinMode (encoder0PinB,INPUT); //channel B 插在DIGITAL 4 Serial.begin (9600); //debuging输出 &#125; void loop() &#123; n = digitalRead(encoder0PinA); //先读取A电位 if ((encoder0PinALast == LOW) &amp;&amp; (n == HIGH)) &#123; //如果A之前是低电位，现在是高电位 if (digitalRead(encoder0PinB) == LOW) &#123; //那么如果B现在低点位 encoder0Pos--; //计数减，反转 &#125; else &#123; //或者如果B现在是高电位 encoder0Pos++; //计数加，正转 &#125; Serial.print (encoder0Pos); Serial.print (&quot;/&quot;); &#125; encoder0PinALast = n; //记录本周期A电位，用于下一周期比较 &#125; 这段代码也没什么不好理解的，相比昨天的接线，只需要把encoder接到analog 0/1 的两根针移到digital 3/4上面就行。 逻辑就是记录A频道的电位，并和上一周期A频道的电位进行比较，如果有差别则说明已经发生位移。在证明已经位移的情况下再读取B频道的电位，得出位移的方向是正还是负。这个逻辑可以参考AB频道的脉冲图谱。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://lucasweichen.github.io/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"https://lucasweichen.github.io/tags/SLAM/"},{"name":"ENCODER","slug":"ENCODER","permalink":"https://lucasweichen.github.io/tags/ENCODER/"}]},{"title":"使用Arduino读取motor encoder马达编码器","slug":"encoder","date":"2017-06-14T03:03:20.000Z","updated":"2017-06-14T03:41:30.641Z","comments":true,"path":"2017/06/13/encoder/","link":"","permalink":"https://lucasweichen.github.io/2017/06/13/encoder/","excerpt":"","text":"实验室的巨型马达需要维修，上面的光学编码器好像也坏了。所以第一步是要学会编码器是什么玩意。鄙人纯软件出身，我知道我写的这些在硬件人士眼中都是儿歌。。。网上有很多资料可以查，magnetic encoder, optical encoder 等等。 工作方式都大同小异。当初导师骗我来说让我focus on machine learning &amp; computer vision。 想一想现在我在学什么我就想笑。。。。 总而言之，树莓派读取编码器比较困难， 用arduino可行性比较高。而编码器本身都没有什么区别。基本4~5个针脚的比较多。 我在实验室地上捡到了2个惠普的HEDS-9100 编码器。盒子已经黄了，可能是打印机喷墨头用的吧我猜。。。。HEDS-9100 网上搜了一堆资料，好像这款编码器还挺流行，很多厂家的资料都有详细的描述。5个针脚从左到右分别是ChB,5V,ChA,N/A,GND. 4号针脚意义不明，我也没有去较真。反正另外4个也够我用了。要注意的是很多编码器是带马达供电的，所以会有更多针脚。 连接本身也没有什么太多可说的，Arduino在硬件操作上比树莓派简单多了，也不需要模拟PWM。 除了编码器的供电接口接在arduino的5v和GND上，AB 两个channel接在arduino的ANALOG-IN的0和1上以读取其值。 另外我接了个喇叭在DIGITAL8 上给反馈。喇叭是从旁边的PC主板上拔下来的。。。。LOL 脑海中浮现出FALLOUT 4，我是快乐的破烂王。呃。。。。找不到合适的东西，就插了个吸管进去。。。。还挺fit….. 代码如下，转动encoder,喇叭会响。赋值那部分有点绕，我也没改，之前玩的时候写了别的没删干净见谅。 代码中的if判断句里面的值选择1000是我观察了它们大概的读数后估计着瞎写的，并没有什么特别意义。但是太敏感的话喇叭会一直响，隔壁的斯里兰卡大哥会不开心。123456789101112131415161718192021222324252627282930313233int pin=8;int analogPin0 = 0;int analogPin1 = 1;int val0 = 0;int val1 = 0;void setup() &#123; // put your setup code here, to run once: pinMode (pin, OUTPUT); Serial.begin(9600);&#125;void loop() &#123; if ((val0-analogRead(analogPin0) &gt; 1000)||(val0-analogRead(analogPin0) &lt; -1000)) &#123; digitalWrite (pin, HIGH); delay(300); digitalWrite (pin, LOW); delay(300); &#125; else if((val1-analogRead(analogPin1) &gt; 1000)||(val1-analogRead(analogPin1) &lt; -1000)) &#123; digitalWrite (pin, HIGH); delay(300); digitalWrite (pin, LOW); delay(300); &#125; val0 = analogRead(analogPin0); val1 = analogRead(analogPin1); Serial.println(val0, val1); // debug value&#125; 已经学会了读取惠普的小编码器，下一步是看看实验室机器人身上的编码器E3","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://lucasweichen.github.io/categories/SLAM/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"ENCODER","slug":"ENCODER","permalink":"https://lucasweichen.github.io/tags/ENCODER/"}]},{"title":"新的开始 day1","slug":"day1","date":"2017-06-07T17:12:44.000Z","updated":"2017-06-14T03:37:11.518Z","comments":true,"path":"2017/06/07/day1/","link":"","permalink":"https://lucasweichen.github.io/2017/06/07/day1/","excerpt":"","text":"I spend all my bachelor &amp; master time to learn to code and study machine vision stuff. Now, as a Phd candidate, my career changed to SLAM robotics, which is quite exciting. I finally jumped out of the boundary of coding and started to do some real welding and soldering. It is not easy, btw, for me, a computer since student to pick all these EE knowledge. But its lot of fun and getting paid. I would say fair enough这几天开始看slam小车的构造，从硬件的角度。以前从未接触过硬件这边，最多只玩过树莓派。 感觉从硬件上说，一个小车/机器人由底盘和各种传感器再加上一个ROS组成。传感器与ROS都比较好理解。对我而言，反而车的底盘成了最神秘的部分。经过一天的阅读，我对底盘的理解有以下几个部分构成： 电机 motor 编码器 encoder 驱动板 上层控制电脑 这里可以是树莓派之类，也可以是笔记本电脑之类 电源与电源控制板 在阅读中已经学习了PWM（Pulse Width Modulatio）的使用，并在树莓派上测试了一段模拟脉冲宽度调制的python代码，如下：arduino 关于pwm的介绍 1234567891011121314151617181920212223#!/usr/bin/env pythonimport RPI.GPIO as GPIOimport timeimport signalimport atexitatexit.register(GPIO.cleanup)servopin=21GPIO.setmode(GPIO.BCM)GPIO.setup(servopin,GPIO.OUT,initial=False)p=GPIO.PWM(servopin,50)p.start(0)time.sleep(2)while(True): for i in range(0,360,10): p.ChangeDutyCycle(12.5-5*i/360) time.sleep(1) for i in range(0,360,10): p.ChangeCutyCycle(7.5-5*i/360) time.sleep(1) 但是要注意这里代码对应的舵机是360度舵机，如果测试180度舵机，试试下面这段代码，写的更直接粗暴简单：123456789101112131415161718192021222324252627282930313233343536373839import RPi.GPIO as GPIOimport timeimport signalimport atexitatexit.register(GPIO.cleanup)servopin1=23servopin2=24GPIO.setmode(GPIO.BCM)GPIO.setup(servopin1,GPIO.OUT,initial=False)GPIO.setup(servopin2,GPIO.OUT,initial=False)p1=GPIO.PWM(servopin1,50)p2=GPIO.PWM(servopin2,50)p1.start(7.5)time.sleep(1)#while(True):# for i in range(0,90,15):# p1.ChangeDutyCycle(12.5-5*i/90)# time.sleep(1)# for i in range(0,90,15):# p2.ChangeCutyCycle(7.5-5*i/90)# time.sleep(1)p1.ChangeDutyCycle(6.5)time.sleep(1)p1.ChangeDutyCycle(2.5)time.sleep(1)p1.ChangeDutyCycle(11.5)time.sleep(1)p2.start(7.5)time.sleep(1)p2.ChangeDutyCycle(6.5)time.sleep(1)p2.ChangeDutyCycle(2.5)time.sleep(1)p2.ChangeDutyCycle(11.5)time.sleep(1) 在学习中我还是不太明白为何初始电位在7.5，逻辑倒是简单粗暴，实际的PWM值会根据你买的电机有多不靠谱而产生浮动，调整一下就好。而且我感觉每次把电机转到最大角度，再拉回来，是不是就是业内统一的初始化方式？ brute force initialization? 附送树莓派1GPIO对照表，如果你也在学这些，请选择没有占用的接口测试舵机。否则舵机会出现迷之抽搐。12345678910111213141516/# define from wiringPi.h # 3.3V | | 5V # 8/SDA | | 5V # 9/SCL | | GND # 7 | | 14/TX # GND | | 15/RX # 0 | | 18 # 2 | | GND # 3 | | 23 # VCC | | 24 # MOSI/12 | | GND # MISO/13 | | 25 # SCK/14 | | 8/CE0 # GND | | 9/CE19 #/ 舵机并不是重点，主要是通过舵机了解PWM的运作原理。另外值得一提的是树莓派对PWM的控制没有arduino精准，抖动好像是正常的，毕竟这是模拟PWM电路，如果真的手动攒小车的话还是需要一块专业的PWM电机驱动板来完成这个过程再反馈给上层树莓派。这样操作的话貌似会稳定很多。哎，伟大旅程的第一步。明天再看看编码器是咋回事儿~","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://lucasweichen.github.io/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"https://lucasweichen.github.io/tags/SLAM/"},{"name":"PWM","slug":"PWM","permalink":"https://lucasweichen.github.io/tags/PWM/"}]},{"title":"hexo 使用 material-flow 主题时更正个人描述部分内容的显示错误问题","slug":"minorfix","date":"2017-06-07T03:25:00.000Z","updated":"2017-06-07T03:47:12.715Z","comments":true,"path":"2017/06/06/minorfix/","link":"","permalink":"https://lucasweichen.github.io/2017/06/06/minorfix/","excerpt":"","text":"意外发现一个小BUG，使用Hexo Material Flow 主题的用户如果想要更改自己的用户简介请编辑主题文件夹中./themes/material-flow/layout/_widget/about.ejs 中的第七行改成：1&lt;div class=&apos;desc&apos;&gt;&lt;%=config.description %&gt;&lt;/div&gt; 全文件如下123456789&lt;section class=&apos;m_widget about&apos;&gt;&lt;% if(config.avatar) &#123; %&gt;&lt;img class=&apos;avatar waves-image&apos; src=&apos;&lt;%= url_for(config.avatar) %&gt;&apos; /&gt;&lt;%&#125; %&gt;&lt;div class=&apos;header&apos;&gt;&lt;%=config.author %&gt;&lt;/div&gt;&lt;div class=&apos;content&apos;&gt;&lt;div class=&apos;desc&apos;&gt;&lt;%=config.description %&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt; 否则个人简介永远都是1Tempora mutantur, nos et mutamur in illis ... 不知道我是不是领会错了，那位做主题的大神是不是意在强行推广什么时过境迁唯我独尊的金句~但是改改也没啥不好哈。。。。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/categories/Hexo/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/tags/Hexo/"}]},{"title":"让git和HEXO记住你的用户名和密码，反正咱也写不出啥值钱的代码","slug":"rem-pass","date":"2017-06-06T06:12:08.000Z","updated":"2017-06-06T06:18:37.150Z","comments":true,"path":"2017/06/05/rem-pass/","link":"","permalink":"https://lucasweichen.github.io/2017/06/05/rem-pass/","excerpt":"","text":"感谢这位大哥的文章看完之后应该就明白了吧。我重述一下：1.打开terminal,使用 ssh-keygen 生成密钥1234$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa) 使用默认的文件名直接enter，接下来显示如下 Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]按提示输入密码即可（简化流程的话在键入命令 ssh-keygen -t rsa -C “your_email@example.com” 以后的三次提示输入都可以直接回车跳过）。密钥生成成功1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:…………………此处是密钥内容…………………… your_email@example.com 2.可以选择是在用户设置中添加密钥（Settings –&gt; SSH GPG keys）还是单个项目中添加密钥，在这里我就在我们的博客项目中添加密钥，此处以我的博客为例。在 chengjianhua.github.io 的首页菜单栏中点击 Settings –&gt; Deploy keys –&gt; Add deploy key，然后将生成的 id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥。 接下来测试配置是否成功1$ ssh -T git@github.com 如果出现以下内容即表示配置完成并且成功！12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 这是大哥说的，我测试了，没反应，不知道是不是被屏蔽了，不然我们这些屌丝乱ssh，anyway反正也不影响使用。3.这时我想到了 hexo 的配置文件 _config.yml 中的 deploy 属性。1234deploy: type: git repo: git@github.com:chengjianhua/chengjianhua.github.io.git branch: master 我将其中的 repo修改成了git@github.com:chengjianhua/chengjianhua.github.io.git，这个时候我再尝试了 $ hexo deploy 果然成功了，就不用输入密码了！ #亲测有效，希望能帮到使用HEXO的同学们","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/categories/Hexo/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/tags/Hexo/"},{"name":"Test","slug":"Test","permalink":"https://lucasweichen.github.io/tags/Test/"}]},{"title":"RememberPassword","slug":"RememberPassword","date":"2017-06-06T06:10:21.000Z","updated":"2017-06-06T06:11:03.264Z","comments":true,"path":"2017/06/05/RememberPassword/","link":"","permalink":"https://lucasweichen.github.io/2017/06/05/RememberPassword/","excerpt":"","text":"#test","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/categories/Hexo/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/tags/Hexo/"},{"name":"Test","slug":"Test","permalink":"https://lucasweichen.github.io/tags/Test/"}]},{"title":"使用Hexo在github写blog","slug":"Got-it-nailed","date":"2017-06-06T05:25:26.000Z","updated":"2017-06-06T05:36:54.830Z","comments":true,"path":"2017/06/05/Got-it-nailed/","link":"","permalink":"https://lucasweichen.github.io/2017/06/05/Got-it-nailed/","excerpt":"","text":"搞了半天终于成功其实别的blog已经把步骤写的很明白!! 但是一定要注意你的github账户本身的设置!!国际友人的本地部署步骤 但是在git的账户设置里一定要记得正确设置git pages否则啥都是扯淡~git官方手册传送门!!一定注意，你的blog repository的正确命名方式是你的用户名+.github.io!!这一点感觉git里面写的不是很明白，之前忘了加上.github.io，捣鼓了半天也没弄明白","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/categories/Hexo/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/tags/Hexo/"}]},{"title":"Testing Post","slug":"Testing-Post","date":"2017-06-06T05:01:38.000Z","updated":"2017-06-06T05:12:43.877Z","comments":true,"path":"2017/06/05/Testing-Post/","link":"","permalink":"https://lucasweichen.github.io/2017/06/05/Testing-Post/","excerpt":"","text":"This is our first post!","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/categories/Hexo/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://lucasweichen.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lucasweichen.github.io/tags/Hexo/"},{"name":"Test","slug":"Test","permalink":"https://lucasweichen.github.io/tags/Test/"}]}]}